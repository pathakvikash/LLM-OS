<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LLM-OS: AI-Powered Application Interface</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      height: 100%;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .app-container {
      display: flex;
      height: 100vh;
      width: 100vw;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }
    
    /* Sidebar */
    .sidebar {
      width: 300px;
      background: rgba(30, 30, 47, 0.95);
      color: white;
      display: flex;
      flex-direction: column;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      overflow-y: auto;
    }
    
    .sidebar-header {
      padding: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.2);
    }
    
    .sidebar-header h1 {
      font-size: 1.5rem;
      margin-bottom: 5px;
      color: #4CAF50;
    }
    
    .sidebar-header p {
      font-size: 0.9rem;
      opacity: 0.7;
    }
    
    .sidebar-section {
      padding: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .sidebar-section h3 {
      margin-bottom: 15px;
      color: #4CAF50;
      font-size: 1rem;
    }
    
    /* Model Selection */
    .model-selector {
      margin-bottom: 15px;
    }
    
    .model-selector select {
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 0.9rem;
    }
    
    .model-selector select option {
      background: #1e1e2f;
      color: white;
    }
    
    .model-info {
      font-size: 0.8rem;
      opacity: 0.7;
      margin-top: 5px;
    }
    
    /* Automation Types */
    .automation-types {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .automation-type {
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.05);
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .automation-type:hover {
      background: rgba(76, 175, 80, 0.2);
      border-color: #4CAF50;
    }
    
    .automation-type.active {
      background: rgba(76, 175, 80, 0.3);
      border-color: #4CAF50;
    }
    
    .automation-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      background: #4CAF50;
      font-size: 0.8rem;
    }
    
    .automation-type span {
      font-size: 0.9rem;
    }
    
    /* Session Management */
    .session-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .session-btn {
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      background: rgba(76, 175, 80, 0.2);
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .session-btn:hover {
      background: rgba(76, 175, 80, 0.4);
    }
    
    .session-btn.danger {
      background: rgba(244, 67, 54, 0.2);
    }
    
    .session-btn.danger:hover {
      background: rgba(244, 67, 54, 0.4);
    }
    
    .session-info {
      font-size: 0.8rem;
      opacity: 0.7;
      margin-top: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
    }
    
    /* Main Content */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    
    .user-section {
      flex: 1;
      background: rgba(255, 255, 255, 0.95);
      margin: 20px;
      border-radius: 12px;
      padding: 30px;
      overflow-y: auto;
      position: relative;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .user-section h2 {
      color: #333;
      margin-bottom: 20px;
      font-size: 1.8rem;
    }
    
    .user-section p {
      color: #666;
      line-height: 1.6;
      margin-bottom: 15px;
    }
    
    .action-buttons {
      position: absolute;
      top: 20px;
      right: 20px;
      display: none;
      gap: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }
    
    .action-buttons button {
      padding: 8px 16px;
      border: none;
      background: linear-gradient(135deg, #4CAF50, #45a049);
      color: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }
    
    .action-buttons button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
    }
    
    /* Chat Section */
    .chat-section {
      height: 400px;
      background: rgba(30, 30, 47, 0.95);
      margin: 0 20px 20px 20px;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .chat-header {
      padding: 15px 20px;
      background: rgba(0, 0, 0, 0.2);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .chat-header h3 {
      color: #4CAF50;
      font-size: 1.1rem;
    }
    
    .chat-status {
      font-size: 0.8rem;
      opacity: 0.7;
    }
    
    .chat-box {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      color: white;
    }
    
    .chat-box p {
      margin-bottom: 15px;
      line-height: 1.5;
    }
    
    .chat-input-container {
      padding: 20px;
      background: rgba(0, 0, 0, 0.2);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .chat-input {
      display: flex;
      gap: 10px;
    }
    
    .chat-input input {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 0.9rem;
    }
    
    .chat-input input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    .chat-input button {
      padding: 12px 20px;
      background: linear-gradient(135deg, #4CAF50, #45a049);
      border: none;
      color: white;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }
    
    .chat-input button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
    }
    
    .chat-input button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    /* Message Styles */
    .loading {
      opacity: 0.6;
      pointer-events: none;
    }
    
    .error {
      color: #ff6b6b;
      font-style: italic;
    }
    
    .system-message {
      color: #a8a8a8;
      font-size: 0.9em;
      font-style: italic;
    }
    
    .context-info {
      background: rgba(255, 255, 255, 0.1);
      padding: 10px;
      margin: 10px 0;
      border-radius: 6px;
      font-size: 0.8em;
      border-left: 3px solid #4CAF50;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }
      
      .sidebar {
        width: 100%;
        height: auto;
        max-height: 300px;
      }
      
      .main-content {
        flex: 1;
      }
      
      .user-section {
        margin: 10px;
        padding: 20px;
      }
      
      .chat-section {
        margin: 0 10px 10px 10px;
        height: 300px;
      }
    }
    
    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .fade-in {
      animation: fadeIn 0.3s ease-out;
    }
    
    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
    }
    
    ::-webkit-scrollbar-thumb {
      background: rgba(76, 175, 80, 0.5);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(76, 175, 80, 0.7);
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="sidebar-header">
        <h1>LLM-OS</h1>
        <p>AI-Powered Application Interface</p>
      </div>
      
      <!-- Model Selection -->
      <div class="sidebar-section">
        <h3>ü§ñ AI Model</h3>
        <div class="model-selector">
          <select id="modelSelect" onchange="changeModel(this.value)">
            <option value="">Loading models...</option>
          </select>
          <div class="model-info" id="modelInfo">Select a model to start</div>
        </div>
      </div>
      
      <!-- Automation Types -->
      <div class="sidebar-section">
        <h3>‚ö° Automation Types</h3>
        <div class="automation-types">
          <div class="automation-type" data-type="edit" onclick="selectAutomationType('edit')">
            <div class="automation-icon">‚úèÔ∏è</div>
            <span>Edit</span>
          </div>
          <div class="automation-type" data-type="ask" onclick="selectAutomationType('ask')">
            <div class="automation-icon">‚ùì</div>
            <span>Ask</span>
          </div>
          <div class="automation-type" data-type="agent" onclick="selectAutomationType('agent')">
            <div class="automation-icon">ü§ñ</div>
            <span>Agent</span>
          </div>
        </div>
      </div>
      
      <!-- Session Management -->
      <div class="sidebar-section">
        <h3>üíæ Session Management</h3>
        <div class="session-controls">
          <button class="session-btn" onclick="createNewChat()">
            <span>üÜï</span> New Chat
          </button>
          <button class="session-btn" onclick="clearSession()">
            <span>üóëÔ∏è</span> Clear Session
          </button>
          <button class="session-btn danger" onclick="resetModel()">
            <span>üîÑ</span> Reset Model
          </button>
        </div>
        <div class="session-info" id="sessionInfo">
          Session: <span id="sessionId">Loading...</span>
        </div>
      </div>
    </div>
    
    <!-- Main Content -->
    <div class="main-content">
      <!-- User Section -->
      <div class="user-section" id="userSection">
        <h2>User Application Section</h2>
        <p>This is your workspace area. Select any text in this section to reveal action buttons for AI-powered automation.</p>
        <p>You can use the automation types from the sidebar to perform different actions on your selected content.</p>
        <div class="action-buttons" id="actionButtons">
          <button onclick="performAction('edit')">‚úèÔ∏è Edit</button>
          <button onclick="performAction('ask')">‚ùì Ask</button>
          <button onclick="performAction('agent')">ü§ñ Agent</button>
        </div>
      </div>
      
      <!-- Chat Section -->
      <div class="chat-section">
        <div class="chat-header">
          <h3>AI Assistant</h3>
          <div class="chat-status" id="chatStatus">Ready</div>
        </div>
        <div class="chat-box" id="chatBox">
          <p><strong>Agent:</strong> Hello! I'm your AI assistant. How can I help you today?</p>
        </div>
        <div class="chat-input-container">
          <div class="chat-input">
            <input type="text" id="userInput" placeholder="Type a message..." onkeypress="handleKeyPress(event)">
            <button onclick="sendMessage()" id="sendButton">Send</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Enhanced Application State Management
    class AppState {
      constructor() {
        this.sessionId = this.generateSessionId();
        this.userContext = new Map();
        this.conversationHistory = [];
        this.currentModel = 'llama3.2:1b'; // Default Ollama model
        this.ollamaEndpoint = '/api/generate'; // Use proxy server
        this.isProcessing = false;
        this.systemPrompt = this.getSystemPrompt();
        this.selectedAutomationType = 'ask'; // Default automation type
        
        // Load state from localStorage if available
        this.loadState();
      }

      generateSessionId() {
        return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }

      getSystemPrompt() {
        return `You are an intelligent AI assistant integrated into a web application. 
        You have access to user context including selected text and application state.
        Always provide helpful, concise, and actionable responses.
        Maintain context awareness and refer to previous conversation when relevant.`;
      }

      updateContext(key, value) {
        this.userContext.set(key, value);
        this.saveState();
        console.log(`Context updated: ${key} = ${value}`);
      }

      getContext(key) {
        return this.userContext.get(key);
      }

      addMessage(role, content, metadata = {}) {
        const message = {
          id: Date.now() + Math.random(),
          role,
          content,
          timestamp: new Date().toISOString(),
          metadata
        };
        this.conversationHistory.push(message);
        this.saveState();
        return message;
      }

      getConversationContext() {
        // Return last 10 messages for context
        return this.conversationHistory.slice(-10);
      }

      saveState() {
        try {
          const stateData = {
            sessionId: this.sessionId,
            userContext: Object.fromEntries(this.userContext),
            conversationHistory: this.conversationHistory.slice(-20), // Keep last 20 messages
            currentModel: this.currentModel,
            selectedAutomationType: this.selectedAutomationType
          };
          localStorage.setItem('llmOS_state', JSON.stringify(stateData));
        } catch (error) {
          console.warn('Failed to save state:', error);
        }
      }

      loadState() {
        try {
          const savedState = localStorage.getItem('llmOS_state');
          if (savedState) {
            const stateData = JSON.parse(savedState);
            this.sessionId = stateData.sessionId || this.sessionId;
            this.userContext = new Map(Object.entries(stateData.userContext || {}));
            this.conversationHistory = stateData.conversationHistory || [];
            this.currentModel = stateData.currentModel || this.currentModel;
            this.selectedAutomationType = stateData.selectedAutomationType || this.selectedAutomationType;
          }
        } catch (error) {
          console.warn('Failed to load state:', error);
        }
      }

      clearSession() {
        this.sessionId = this.generateSessionId();
        this.conversationHistory = [];
        this.userContext.clear();
        this.saveState();
      }

      resetModel() {
        // Reset to default model and clear cache
        this.currentModel = 'llama3.2:1b';
        localStorage.removeItem('llmOS_state');
        console.log('Model reset to default: llama3.2:1b');
      }

      setAutomationType(type) {
        this.selectedAutomationType = type;
        this.saveState();
      }
    }

    // Ollama API Integration
    class OllamaAPI {
      constructor(endpoint) {
        this.endpoint = endpoint;
      }

      async chat(messages, model = 'llama3.2:1b', options = {}) {
        // Convert chat messages to a single prompt for generate endpoint
        const prompt = this.convertMessagesToPrompt(messages);
        
        const requestBody = {
          model: model,
          prompt: prompt,
          stream: false,
          options: {
            temperature: options.temperature || 0.7,
            top_p: options.top_p || 0.9,
            ...options
          }
        };

        try {
          const response = await fetch(this.endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
            },
            mode: 'cors',
            credentials: 'omit',
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            const errorText = await response.text();
            let errorMessage = `HTTP error! status: ${response.status}`;
            
            try {
              const errorData = JSON.parse(errorText);
              if (errorData.error && errorData.error.includes('model') && errorData.error.includes('not found')) {
                errorMessage = `Model '${model}' not found. Please ensure the model is pulled with: ollama pull ${model}`;
              } else if (errorData.error) {
                errorMessage = `Ollama error: ${errorData.error}`;
              }
            } catch (e) {
              if (errorText.includes('model') && errorText.includes('not found')) {
                errorMessage = `Model '${model}' not found. Please ensure the model is pulled with: ollama pull ${model}`;
              }
            }
            
            throw new Error(errorMessage);
          }

          const data = await response.json();
          return data.response;
        } catch (error) {
          console.error('Ollama API error:', error);
          
          if (error.message.includes('CORS') || error.message.includes('preflight')) {
            throw new Error('CORS Error: Make sure Ollama is running and accessible. You may need to configure CORS in Ollama or use a proxy.');
          }
          
          throw error;
        }
      }

      convertMessagesToPrompt(messages) {
        let prompt = '';
        
        for (const message of messages) {
          if (message.role === 'system') {
            prompt += `System: ${message.content}\n\n`;
          } else if (message.role === 'user') {
            prompt += `User: ${message.content}\n\n`;
          } else if (message.role === 'assistant') {
            prompt += `Assistant: ${message.content}\n\n`;
          }
        }
        
        prompt += 'Assistant: ';
        return prompt;
      }

      async getAvailableModels() {
        try {
          const response = await fetch('/api/tags', {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
            },
            mode: 'cors',
            credentials: 'omit'
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          return data.models || [];
        } catch (error) {
          console.error('Failed to fetch models:', error);
          return [];
        }
      }

      async validateAndSelectModel(currentModel) {
        try {
          const availableModels = await this.getAvailableModels();
          console.log('Available models:', availableModels);
          
          const modelExists = availableModels.some(model => model.name === currentModel);
          
          if (!modelExists && availableModels.length > 0) {
            const fallbackModel = availableModels[0].name;
            console.log(`Model '${currentModel}' not found, using '${fallbackModel}' instead`);
            return fallbackModel;
          }
          
          return currentModel;
        } catch (error) {
          console.error('Error validating model:', error);
          return currentModel;
        }
      }
    }

    // UI Management
    class UIManager {
      constructor() {
        this.chatBox = document.getElementById('chatBox');
        this.userInput = document.getElementById('userInput');
        this.sendButton = document.getElementById('sendButton');
        this.actionButtons = document.getElementById('actionButtons');
        this.modelSelect = document.getElementById('modelSelect');
        this.modelInfo = document.getElementById('modelInfo');
        this.sessionInfo = document.getElementById('sessionInfo');
        this.sessionId = document.getElementById('sessionId');
        this.chatStatus = document.getElementById('chatStatus');
      }

      addMessage(message, type = 'user') {
        const messageElement = document.createElement('p');
        messageElement.className = 'fade-in';
        
        if (type === 'user') {
          messageElement.innerHTML = `<strong>You:</strong> ${this.escapeHtml(message)}`;
        } else if (type === 'agent') {
          messageElement.innerHTML = `<strong>Agent:</strong> ${this.escapeHtml(message)}`;
        } else if (type === 'system') {
          messageElement.className = 'system-message fade-in';
          messageElement.innerHTML = `<strong>System:</strong> ${this.escapeHtml(message)}`;
        } else if (type === 'error') {
          messageElement.className = 'error fade-in';
          messageElement.innerHTML = `<strong>Error:</strong> ${this.escapeHtml(message)}`;
        }

        this.chatBox.appendChild(messageElement);
        this.scrollToBottom();
      }

      addContextInfo(context) {
        if (!context || Object.keys(context).length === 0) return;
        
        const contextElement = document.createElement('div');
        contextElement.className = 'context-info fade-in';
        contextElement.innerHTML = `<strong>Context:</strong> ${this.escapeHtml(JSON.stringify(context, null, 2))}`;
        this.chatBox.appendChild(contextElement);
        this.scrollToBottom();
      }

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      scrollToBottom() {
        this.chatBox.scrollTop = this.chatBox.scrollHeight;
      }

      setLoading(loading) {
        this.sendButton.disabled = loading;
        this.userInput.disabled = loading;
        this.sendButton.textContent = loading ? 'Processing...' : 'Send';
        this.chatStatus.textContent = loading ? 'Processing...' : 'Ready';
        
        if (loading) {
          this.userInput.classList.add('loading');
        } else {
          this.userInput.classList.remove('loading');
        }
      }

      showActionButtons(show) {
        this.actionButtons.style.display = show ? 'flex' : 'none';
      }

      updateModelSelect(models, currentModel) {
        this.modelSelect.innerHTML = '';
        
        if (models.length === 0) {
          this.modelSelect.innerHTML = '<option value="">No models available</option>';
          this.modelInfo.textContent = 'No models found. Please pull a model with: ollama pull <model-name>';
          return;
        }
        
        models.forEach(model => {
          const option = document.createElement('option');
          option.value = model.name;
          option.textContent = model.name;
          if (model.name === currentModel) {
            option.selected = true;
          }
          this.modelSelect.appendChild(option);
        });
        
        this.modelInfo.textContent = `Using: ${currentModel}`;
      }

      updateSessionInfo(sessionId) {
        this.sessionId.textContent = sessionId.substring(0, 20) + '...';
      }

      selectAutomationType(type) {
        // Remove active class from all automation types
        document.querySelectorAll('.automation-type').forEach(el => {
          el.classList.remove('active');
        });
        
        // Add active class to selected type
        const selectedElement = document.querySelector(`[data-type="${type}"]`);
        if (selectedElement) {
          selectedElement.classList.add('active');
        }
      }
    }

    // Main Application Controller
    class AppController {
      constructor() {
        this.state = new AppState();
        this.ui = new UIManager();
        this.ollama = new OllamaAPI(this.state.ollamaEndpoint);
        
        this.initializeEventListeners();
        this.initializeModel();
        this.loadConversationHistory();
        this.updateUI();
      }

      initializeEventListeners() {
        // Text selection handling
        document.getElementById('userSection').addEventListener('mouseup', () => {
          const selection = window.getSelection().toString().trim();
          if (selection) {
            this.state.updateContext('selectedText', selection);
            this.ui.showActionButtons(true);
          } else {
            this.ui.showActionButtons(false);
          }
        });

        // Enter key handling
        document.getElementById('userInput').addEventListener('keypress', (event) => {
          if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            this.sendMessage();
          }
        });
      }

      async initializeModel() {
        try {
          const validatedModel = await this.ollama.validateAndSelectModel(this.state.currentModel);
          
          if (validatedModel !== this.state.currentModel) {
            this.state.currentModel = validatedModel;
            this.state.saveState();
            this.ui.addMessage(`Model changed to: ${validatedModel}`, 'system');
          } else {
            this.ui.addMessage(`Using model: ${validatedModel}`, 'system');
          }
          
          // Update model selector
          const models = await this.ollama.getAvailableModels();
          this.ui.updateModelSelect(models, this.state.currentModel);
          
        } catch (error) {
          console.error('Error initializing model:', error);
          this.ui.addMessage(`Error initializing model: ${error.message}`, 'error');
        }
      }

      updateUI() {
        this.ui.updateSessionInfo(this.state.sessionId);
        this.ui.selectAutomationType(this.state.selectedAutomationType);
      }

      async sendMessage() {
        const message = this.ui.userInput.value.trim();
        if (!message || this.state.isProcessing) return;

        this.state.isProcessing = true;
        this.ui.setLoading(true);

        try {
          this.ui.addMessage(message, 'user');
          this.state.addMessage('user', message);
          this.ui.userInput.value = '';

          const context = this.buildContext();
          const aiResponse = await this.getAIResponse(message, context);

          this.ui.addMessage(aiResponse, 'agent');
          this.state.addMessage('assistant', aiResponse);

        } catch (error) {
          console.error('Error sending message:', error);
          this.ui.addMessage(`Failed to get response: ${error.message}`, 'error');
        } finally {
          this.state.isProcessing = false;
          this.ui.setLoading(false);
        }
      }

      buildContext() {
        const context = {
          selectedText: this.state.getContext('selectedText'),
          sessionId: this.state.sessionId,
          conversationLength: this.state.conversationHistory.length,
          currentModel: this.state.currentModel,
          automationType: this.state.selectedAutomationType
        };

        const recentMessages = this.state.getConversationContext();
        if (recentMessages.length > 0) {
          context.recentConversation = recentMessages.map(msg => ({
            role: msg.role,
            content: msg.content.substring(0, 200)
          }));
        }

        return context;
      }

      async getAIResponse(userMessage, context) {
        const messages = [
          { role: 'system', content: this.state.systemPrompt },
          ...this.state.getConversationContext().map(msg => ({
            role: msg.role,
            content: msg.content
          })),
          { role: 'user', content: this.buildPrompt(userMessage, context) }
        ];

        return await this.ollama.chat(messages, this.state.currentModel);
      }

      buildPrompt(userMessage, context) {
        let prompt = userMessage;

        if (context.selectedText) {
          prompt += `\n\nSelected text: "${context.selectedText}"`;
        }

        if (context.automationType) {
          prompt += `\n\nAutomation type: ${context.automationType}`;
        }

        if (context.recentConversation && context.recentConversation.length > 0) {
          prompt += `\n\nRecent conversation context: ${JSON.stringify(context.recentConversation)}`;
        }

        return prompt;
      }

      async performAction(actionType) {
        const selected = this.state.getContext('selectedText') || "[no selection]";
        const actionMessage = `${actionType.toUpperCase()} request on: ${selected}`;
        
        this.ui.addMessage(actionMessage, 'user');
        this.state.addMessage('user', actionMessage);

        try {
          const context = this.buildContext();
          const response = await this.getAIResponse(actionMessage, context);
          
          this.ui.addMessage(response, 'agent');
          this.state.addMessage('assistant', response);
        } catch (error) {
          this.ui.addMessage(`Action failed: ${error.message}`, 'error');
        }
      }

      loadConversationHistory() {
        const recentMessages = this.state.getConversationContext();
        recentMessages.forEach(msg => {
          if (msg.role === 'user') {
            this.ui.addMessage(msg.content, 'user');
          } else if (msg.role === 'assistant') {
            this.ui.addMessage(msg.content, 'agent');
          }
        });
      }

      async changeModel(modelName) {
        try {
          const models = await this.ollama.getAvailableModels();
          const modelExists = models.some(model => model.name === modelName);
          
          if (modelExists) {
            this.state.currentModel = modelName;
            this.state.saveState();
            this.ui.updateModelSelect(models, modelName);
            this.ui.addMessage(`Model changed to: ${modelName}`, 'system');
          } else {
            this.ui.addMessage(`Model ${modelName} not available`, 'error');
          }
        } catch (error) {
          this.ui.addMessage(`Failed to change model: ${error.message}`, 'error');
        }
      }

      clearSession() {
        this.state.clearSession();
        this.chatBox.innerHTML = '<p><strong>Agent:</strong> Session cleared. How can I help you?</p>';
        this.ui.addMessage('Session cleared', 'system');
        this.updateUI();
      }

      createNewChat() {
        this.state.clearSession();
        this.chatBox.innerHTML = '<p><strong>Agent:</strong> New chat started. How can I help you?</p>';
        this.ui.addMessage('New chat created', 'system');
        this.updateUI();
      }

      selectAutomationType(type) {
        this.state.setAutomationType(type);
        this.ui.selectAutomationType(type);
        this.ui.addMessage(`Automation type set to: ${type}`, 'system');
      }
    }

    // Initialize the application
    let app;
    
    document.addEventListener('DOMContentLoaded', () => {
      app = new AppController();
      
      // Make functions globally available
      window.sendMessage = () => app.sendMessage();
      window.performAction = (actionType) => app.performAction(actionType);
      window.handleKeyPress = (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          app.sendMessage();
        }
      };

      // UI Functions
      window.changeModel = (modelName) => app.changeModel(modelName);
      window.selectAutomationType = (type) => app.selectAutomationType(type);
      window.createNewChat = () => app.createNewChat();
      window.clearSession = () => app.clearSession();
      window.resetModel = () => {
        app.state.resetModel();
        location.reload();
      };
      
      // Debug functions
      window.checkModels = async () => {
        const models = await app.ollama.getAvailableModels();
        console.log('Available models:', models);
        app.ui.addMessage(`Available models: ${models.map(m => m.name).join(', ')}`, 'system');
      };
    });
  </script>
</body>
</html>