<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LLM-OS: AI-Powered Application Interface</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="app-container">
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="header-content">
          <h1>LLM-OS</h1>
          <p>AI-Powered Application Interface</p>
        </div>
        <button class="collapse-btn" onclick="toggleSidebar()" title="Toggle Sidebar">
          <span>‚óÄ</span>
        </button>
      </div>
      
      <!-- Model Selection -->
      <div class="sidebar-section">
        <h3>ü§ñ AI Model</h3>
        <div class="model-selector">
          <select id="modelSelect" onchange="changeModel(this.value)">
            <option value="">Loading models...</option>
          </select>
          <div class="model-info" id="modelInfo">Select a model to start</div>
        </div>
      </div>
      
      <!-- Automation Types -->
      <div class="sidebar-section">
        <h3>‚ö° Automation Types</h3>
        <div class="automation-types">
          <div class="automation-type" data-type="edit" onclick="selectAutomationType('edit')">
            <div class="automation-icon">‚úèÔ∏è</div>
            <span>Edit</span>
          </div>
          <div class="automation-type" data-type="ask" onclick="selectAutomationType('ask')">
            <div class="automation-icon">‚ùì</div>
            <span>Ask</span>
          </div>
          <div class="automation-type" data-type="agent" onclick="selectAutomationType('agent')">
            <div class="automation-icon">ü§ñ</div>
            <span>Agent</span>
          </div>
        </div>
      </div>
      
      <!-- Session Management -->
      <div class="sidebar-section">
        <h3>üíæ Session Management</h3>
        <div class="session-controls">
          <button class="session-btn" onclick="createNewChat()">
            <span>üÜï</span> New Chat
          </button>
          <button class="session-btn" onclick="clearSession()">
            <span>üóëÔ∏è</span> Clear Session
          </button>
          <button class="session-btn danger" onclick="resetModel()">
            <span>üîÑ</span> Reset Model
          </button>
        </div>
        <div class="session-info" id="sessionInfo">
          Session: <span id="sessionId">Loading...</span>
        </div>
      </div>
    </div>
    <div class="sidebar-peek peek-bar" id="sidebarPeek" title="Show Sidebar" onclick="restoreSidebar()" onmouseenter="peekSidebar(true)" onmouseleave="peekSidebar(false)">‚ñ∂</div>
    
    <!-- Main Content -->
    <div class="main-content" id="mainContent">
      <!-- User Section -->
      <div class="user-section" id="userSection">
        <div class="section-header">
          <h2>User Application Section</h2>
          <button class="collapse-btn" onclick="toggleUserSection()" title="Toggle User Section">
            <span>‚ñº</span>
          </button>
        </div>
        <div class="section-content">
          <p>This is your workspace area. Select any text in this section to reveal action buttons for AI-powered automation.</p>
          <p>You can use the automation types from the sidebar to perform different actions on your selected content.</p>
          <div class="action-buttons" id="actionButtons">
            <button onclick="performAction('edit')">‚úèÔ∏è Edit</button>
            <button onclick="performAction('ask')">‚ùì Ask</button>
            <button onclick="performAction('agent')">ü§ñ Agent</button>
          </div>
        </div>
      </div>
      <div class="user-peek peek-bar" id="userPeek" title="Show User Section" onclick="restoreUserSection()" onmouseenter="peekUserSection(true)" onmouseleave="peekUserSection(false)">‚ñº</div>
      
      <!-- Chat Section -->
      <div class="chat-section" id="chatSection">
        <div class="chat-header">
          <h3>AI Assistant</h3>
          <div class="header-controls">
            <div class="chat-status" id="chatStatus">Ready</div>
            <button class="collapse-btn" onclick="toggleChatSection()" title="Toggle Chat Section">
              <span>‚ñº</span>
            </button>
          </div>
        </div>
        <div class="chat-content">
          <div class="chat-box" id="chatBox">
            <p><strong>Agent:</strong> Hello! I'm your AI assistant. How can I help you today?</p>
          </div>
          <div class="chat-input-container">
            <div class="chat-input">
              <input type="text" id="userInput" placeholder="Type a message..." onkeypress="handleKeyPress(event)">
              <button onclick="sendMessage()" id="sendButton">Send</button>
            </div>
          </div>
        </div>
      </div>
      <div class="chat-peek peek-bar" id="chatPeek" title="Show Chat Section" onclick="restoreChatSection()" onmouseenter="peekChatSection(true)" onmouseleave="peekChatSection(false)">‚ñ≤</div>
    </div>
  </div>

  <script>
    // Enhanced Application State Management
    class AppState {
      constructor() {
        this.sessionId = this.generateSessionId();
        this.userContext = new Map();
        this.conversationHistory = [];
        this.currentModel = 'llama3.2:1b'; // Default Ollama model
        this.ollamaEndpoint = '/api/generate'; // Use proxy server
        this.isProcessing = false;
        this.systemPrompt = this.getSystemPrompt();
        this.selectedAutomationType = 'ask'; // Default automation type
        
        // UI State Management
        this.uiState = {
          sidebarVisible: true,
          userSectionVisible: true,
          chatSectionVisible: true
        };
        
        // Load state from localStorage if available
        this.loadState();
      }

      generateSessionId() {
        return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }

      getSystemPrompt() {
        return `You are an intelligent AI assistant integrated into a web application. 
        You have access to user context including selected text and application state.
        Always provide helpful, concise, and actionable responses.
        Maintain context awareness and refer to previous conversation when relevant.`;
      }

      updateContext(key, value) {
        this.userContext.set(key, value);
        this.saveState();
        console.log(`Context updated: ${key} = ${value}`);
      }

      getContext(key) {
        return this.userContext.get(key);
      }

      addMessage(role, content, metadata = {}) {
        const message = {
          id: Date.now() + Math.random(),
          role,
          content,
          timestamp: new Date().toISOString(),
          metadata
        };
        this.conversationHistory.push(message);
        this.saveState();
        return message;
      }

      getConversationContext() {
        // Return last 10 messages for context
        return this.conversationHistory.slice(-10);
      }

      saveState() {
        try {
          const stateData = {
            sessionId: this.sessionId,
            userContext: Object.fromEntries(this.userContext),
            conversationHistory: this.conversationHistory.slice(-20), // Keep last 20 messages
            currentModel: this.currentModel,
            selectedAutomationType: this.selectedAutomationType,
            uiState: this.uiState
          };
          localStorage.setItem('llmOS_state', JSON.stringify(stateData));
        } catch (error) {
          console.warn('Failed to save state:', error);
        }
      }

      loadState() {
        try {
          const savedState = localStorage.getItem('llmOS_state');
          if (savedState) {
            const stateData = JSON.parse(savedState);
            this.sessionId = stateData.sessionId || this.sessionId;
            this.userContext = new Map(Object.entries(stateData.userContext || {}));
            this.conversationHistory = stateData.conversationHistory || [];
            this.currentModel = stateData.currentModel || this.currentModel;
            this.selectedAutomationType = stateData.selectedAutomationType || this.selectedAutomationType;
            this.uiState = { ...this.uiState, ...stateData.uiState };
          }
        } catch (error) {
          console.warn('Failed to load state:', error);
        }
      }

      clearSession() {
        this.sessionId = this.generateSessionId();
        this.conversationHistory = [];
        this.userContext.clear();
        this.saveState();
      }

      resetModel() {
        // Reset to default model and clear cache
        this.currentModel = 'llama3.2:1b';
        localStorage.removeItem('llmOS_state');
        console.log('Model reset to default: llama3.2:1b');
      }

      setAutomationType(type) {
        this.selectedAutomationType = type;
        this.saveState();
      }

      // UI State Management
      updateUIState(key, value) {
        this.uiState[key] = value;
        this.saveState();
      }

      canHideSection(sectionName) {
        const visibleSections = Object.values(this.uiState).filter(visible => visible).length;
        return visibleSections > 1 || !this.uiState[sectionName];
      }
    }

    // Ollama API Integration
    class OllamaAPI {
      constructor(endpoint) {
        this.endpoint = endpoint;
      }

      async chat(messages, model = 'llama3.2:1b', options = {}) {
        // Convert chat messages to a single prompt for generate endpoint
        const prompt = this.convertMessagesToPrompt(messages);
        
        const requestBody = {
          model: model,
          prompt: prompt,
          stream: false,
          options: {
            temperature: options.temperature || 0.7,
            top_p: options.top_p || 0.9,
            ...options
          }
        };

        try {
          const response = await fetch(this.endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
            },
            mode: 'cors',
            credentials: 'omit',
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            const errorText = await response.text();
            let errorMessage = `HTTP error! status: ${response.status}`;
            
            try {
              const errorData = JSON.parse(errorText);
              if (errorData.error && errorData.error.includes('model') && errorData.error.includes('not found')) {
                errorMessage = `Model '${model}' not found. Please ensure the model is pulled with: ollama pull ${model}`;
              } else if (errorData.error) {
                errorMessage = `Ollama error: ${errorData.error}`;
              }
            } catch (e) {
              if (errorText.includes('model') && errorText.includes('not found')) {
                errorMessage = `Model '${model}' not found. Please ensure the model is pulled with: ollama pull ${model}`;
              }
            }
            
            throw new Error(errorMessage);
          }

          const data = await response.json();
          return data.response;
        } catch (error) {
          console.error('Ollama API error:', error);
          
          if (error.message.includes('CORS') || error.message.includes('preflight')) {
            throw new Error('CORS Error: Make sure Ollama is running and accessible. You may need to configure CORS in Ollama or use a proxy.');
          }
          
          throw error;
        }
      }

      convertMessagesToPrompt(messages) {
        let prompt = '';
        
        for (const message of messages) {
          if (message.role === 'system') {
            prompt += `System: ${message.content}\n\n`;
          } else if (message.role === 'user') {
            prompt += `User: ${message.content}\n\n`;
          } else if (message.role === 'assistant') {
            prompt += `Assistant: ${message.content}\n\n`;
          }
        }
        
        prompt += 'Assistant: ';
        return prompt;
      }

      async getAvailableModels() {
        try {
          const response = await fetch('/api/tags', {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
            },
            mode: 'cors',
            credentials: 'omit'
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          return data.models || [];
        } catch (error) {
          console.error('Failed to fetch models:', error);
          return [];
        }
      }

      async validateAndSelectModel(currentModel) {
        try {
          const availableModels = await this.getAvailableModels();
          console.log('Available models:', availableModels);
          
          const modelExists = availableModels.some(model => model.name === currentModel);
          
          if (!modelExists && availableModels.length > 0) {
            const fallbackModel = availableModels[0].name;
            console.log(`Model '${currentModel}' not found, using '${fallbackModel}' instead`);
            return fallbackModel;
          }
          
          return currentModel;
        } catch (error) {
          console.error('Error validating model:', error);
          return currentModel;
        }
      }
    }

    // UI Management
    class UIManager {
      constructor() {
        this.chatBox = document.getElementById('chatBox');
        this.userInput = document.getElementById('userInput');
        this.sendButton = document.getElementById('sendButton');
        this.actionButtons = document.getElementById('actionButtons');
        this.modelSelect = document.getElementById('modelSelect');
        this.modelInfo = document.getElementById('modelInfo');
        this.sessionInfo = document.getElementById('sessionInfo');
        this.sessionId = document.getElementById('sessionId');
        this.chatStatus = document.getElementById('chatStatus');
        
        // Section elements
        this.sidebar = document.getElementById('sidebar');
        this.userSection = document.getElementById('userSection');
        this.chatSection = document.getElementById('chatSection');
        this.mainContent = document.getElementById('mainContent');
      }

      addMessage(message, type = 'user') {
        const messageElement = document.createElement('p');
        messageElement.className = 'fade-in';
        
        if (type === 'user') {
          messageElement.innerHTML = `<strong>You:</strong> ${this.escapeHtml(message)}`;
        } else if (type === 'agent') {
          messageElement.innerHTML = `<strong>Agent:</strong> ${this.escapeHtml(message)}`;
        } else if (type === 'system') {
          messageElement.className = 'system-message fade-in';
          messageElement.innerHTML = `<strong>System:</strong> ${this.escapeHtml(message)}`;
        } else if (type === 'error') {
          messageElement.className = 'error fade-in';
          messageElement.innerHTML = `<strong>Error:</strong> ${this.escapeHtml(message)}`;
        }

        this.chatBox.appendChild(messageElement);
        this.scrollToBottom();
      }

      addContextInfo(context) {
        if (!context || Object.keys(context).length === 0) return;
        
        const contextElement = document.createElement('div');
        contextElement.className = 'context-info fade-in';
        contextElement.innerHTML = `<strong>Context:</strong> ${this.escapeHtml(JSON.stringify(context, null, 2))}`;
        this.chatBox.appendChild(contextElement);
        this.scrollToBottom();
      }

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      scrollToBottom() {
        this.chatBox.scrollTop = this.chatBox.scrollHeight;
      }

      setLoading(loading) {
        this.sendButton.disabled = loading;
        this.userInput.disabled = loading;
        this.sendButton.textContent = loading ? 'Processing...' : 'Send';
        this.chatStatus.textContent = loading ? 'Processing...' : 'Ready';
        
        if (loading) {
          this.userInput.classList.add('loading');
        } else {
          this.userInput.classList.remove('loading');
        }
      }

      showActionButtons(show) {
        this.actionButtons.style.display = show ? 'flex' : 'none';
      }

      updateModelSelect(models, currentModel) {
        this.modelSelect.innerHTML = '';
        
        if (models.length === 0) {
          this.modelSelect.innerHTML = '<option value="">No models available</option>';
          this.modelInfo.textContent = 'No models found. Please pull a model with: ollama pull <model-name>';
          return;
        }
        
        models.forEach(model => {
          const option = document.createElement('option');
          option.value = model.name;
          option.textContent = model.name;
          if (model.name === currentModel) {
            option.selected = true;
          }
          this.modelSelect.appendChild(option);
        });
        
        this.modelInfo.textContent = `Using: ${currentModel}`;
      }

      updateSessionInfo(sessionId) {
        this.sessionId.textContent = sessionId.substring(0, 20) + '...';
      }

      selectAutomationType(type) {
        // Remove active class from all automation types
        document.querySelectorAll('.automation-type').forEach(el => {
          el.classList.remove('active');
        });
        
        // Add active class to selected type
        const selectedElement = document.querySelector(`[data-type="${type}"]`);
        if (selectedElement) {
          selectedElement.classList.add('active');
        }
      }

      // Section visibility management
      toggleSection(sectionName, visible) {
        const section = this[sectionName];
        if (!section) return;

        if (visible) {
          section.classList.remove('collapsed');
          section.classList.add('visible');
        } else {
          section.classList.add('collapsed');
          section.classList.remove('visible');
        }

        // Update layout
        this.updateLayout();
      }

      updateLayout() {
        // Add/remove classes to main container based on visible sections
        const sidebarVisible = !this.sidebar.classList.contains('collapsed');
        const userVisible = !this.userSection.classList.contains('collapsed');
        const chatVisible = !this.chatSection.classList.contains('collapsed');

        this.mainContent.className = 'main-content';
        
        if (!sidebarVisible) {
          this.mainContent.classList.add('sidebar-hidden');
        }
        if (!userVisible) {
          this.mainContent.classList.add('user-hidden');
        }
        if (!chatVisible) {
          this.mainContent.classList.add('chat-hidden');
        }
      }

      updateCollapseButtons() {
        // Update button text based on current state
        const sidebarBtn = this.sidebar.querySelector('.collapse-btn span');
        const userBtn = this.userSection.querySelector('.collapse-btn span');
        const chatBtn = this.chatSection.querySelector('.collapse-btn span');

        sidebarBtn.textContent = this.sidebar.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
        userBtn.textContent = this.userSection.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
        chatBtn.textContent = this.chatSection.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
      }
    }

    // Main Application Controller
    class AppController {
      constructor() {
        this.state = new AppState();
        this.ui = new UIManager();
        this.ollama = new OllamaAPI(this.state.ollamaEndpoint);
        
        this.initializeEventListeners();
        this.initializeModel();
        this.loadConversationHistory();
        this.updateUI();
        this.applySavedUIState();
      }

      initializeEventListeners() {
        // Text selection handling
        document.getElementById('userSection').addEventListener('mouseup', () => {
          const selection = window.getSelection().toString().trim();
          if (selection) {
            this.state.updateContext('selectedText', selection);
            this.ui.showActionButtons(true);
          } else {
            this.ui.showActionButtons(false);
          }
        });

        // Enter key handling
        document.getElementById('userInput').addEventListener('keypress', (event) => {
          if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            this.sendMessage();
          }
        });
      }

      async initializeModel() {
        try {
          const validatedModel = await this.ollama.validateAndSelectModel(this.state.currentModel);
          
          if (validatedModel !== this.state.currentModel) {
            this.state.currentModel = validatedModel;
            this.state.saveState();
            this.ui.addMessage(`Model changed to: ${validatedModel}`, 'system');
          } else {
            this.ui.addMessage(`Using model: ${validatedModel}`, 'system');
          }
          
          // Update model selector
          const models = await this.ollama.getAvailableModels();
          this.ui.updateModelSelect(models, this.state.currentModel);
          
        } catch (error) {
          console.error('Error initializing model:', error);
          this.ui.addMessage(`Error initializing model: ${error.message}`, 'error');
        }
      }

      updateUI() {
        this.ui.updateSessionInfo(this.state.sessionId);
        this.ui.selectAutomationType(this.state.selectedAutomationType);
      }

      applySavedUIState() {
        // Apply saved UI state
        this.ui.toggleSection('sidebar', this.state.uiState.sidebarVisible);
        this.ui.toggleSection('userSection', this.state.uiState.userSectionVisible);
        this.ui.toggleSection('chatSection', this.state.uiState.chatSectionVisible);
        this.ui.updateCollapseButtons();
      }

      async sendMessage() {
        const message = this.ui.userInput.value.trim();
        if (!message || this.state.isProcessing) return;

        this.state.isProcessing = true;
        this.ui.setLoading(true);

        try {
          this.ui.addMessage(message, 'user');
          this.state.addMessage('user', message);
          this.ui.userInput.value = '';

          const context = this.buildContext();
          const aiResponse = await this.getAIResponse(message, context);

          this.ui.addMessage(aiResponse, 'agent');
          this.state.addMessage('assistant', aiResponse);

        } catch (error) {
          console.error('Error sending message:', error);
          this.ui.addMessage(`Failed to get response: ${error.message}`, 'error');
        } finally {
          this.state.isProcessing = false;
          this.ui.setLoading(false);
        }
      }

      buildContext() {
        const context = {
          selectedText: this.state.getContext('selectedText'),
          sessionId: this.state.sessionId,
          conversationLength: this.state.conversationHistory.length,
          currentModel: this.state.currentModel,
          automationType: this.state.selectedAutomationType
        };

        const recentMessages = this.state.getConversationContext();
        if (recentMessages.length > 0) {
          context.recentConversation = recentMessages.map(msg => ({
            role: msg.role,
            content: msg.content.substring(0, 200)
          }));
        }

        return context;
      }

      async getAIResponse(userMessage, context) {
        const messages = [
          { role: 'system', content: this.state.systemPrompt },
          ...this.state.getConversationContext().map(msg => ({
            role: msg.role,
            content: msg.content
          })),
          { role: 'user', content: this.buildPrompt(userMessage, context) }
        ];

        return await this.ollama.chat(messages, this.state.currentModel);
      }

      buildPrompt(userMessage, context) {
        let prompt = userMessage;

        if (context.selectedText) {
          prompt += `\n\nSelected text: "${context.selectedText}"`;
        }

        if (context.automationType) {
          prompt += `\n\nAutomation type: ${context.automationType}`;
        }

        if (context.recentConversation && context.recentConversation.length > 0) {
          prompt += `\n\nRecent conversation context: ${JSON.stringify(context.recentConversation)}`;
        }

        return prompt;
      }

      async performAction(actionType) {
        const selected = this.state.getContext('selectedText') || "[no selection]";
        const actionMessage = `${actionType.toUpperCase()} request on: ${selected}`;
        
        this.ui.addMessage(actionMessage, 'user');
        this.state.addMessage('user', actionMessage);

        try {
          const context = this.buildContext();
          const response = await this.getAIResponse(actionMessage, context);
          
          this.ui.addMessage(response, 'agent');
          this.state.addMessage('assistant', response);
        } catch (error) {
          this.ui.addMessage(`Action failed: ${error.message}`, 'error');
        }
      }

      loadConversationHistory() {
        const recentMessages = this.state.getConversationContext();
        recentMessages.forEach(msg => {
          if (msg.role === 'user') {
            this.ui.addMessage(msg.content, 'user');
          } else if (msg.role === 'assistant') {
            this.ui.addMessage(msg.content, 'agent');
          }
        });
      }

      async changeModel(modelName) {
        try {
          const models = await this.ollama.getAvailableModels();
          const modelExists = models.some(model => model.name === modelName);
          
          if (modelExists) {
            this.state.currentModel = modelName;
            this.state.saveState();
            this.ui.updateModelSelect(models, modelName);
            this.ui.addMessage(`Model changed to: ${modelName}`, 'system');
          } else {
            this.ui.addMessage(`Model ${modelName} not available`, 'error');
          }
        } catch (error) {
          this.ui.addMessage(`Failed to change model: ${error.message}`, 'error');
        }
      }

      clearSession() {
        this.state.clearSession();
        this.ui.chatBox.innerHTML = '<p><strong>Agent:</strong> Session cleared. How can I help you?</p>';
        this.ui.addMessage('Session cleared', 'system');
        this.updateUI();
      }

      createNewChat() {
        this.state.clearSession();
        this.ui.chatBox.innerHTML = '<p><strong>Agent:</strong> New chat started. How can I help you?</p>';
        this.ui.addMessage('New chat created', 'system');
        this.updateUI();
      }

      selectAutomationType(type) {
        this.state.setAutomationType(type);
        this.ui.selectAutomationType(type);
        this.ui.addMessage(`Automation type set to: ${type}`, 'system');
      }

      // Section toggle methods
      toggleSidebar() {
        if (this.state.canHideSection('sidebarVisible')) {
          const newState = !this.state.uiState.sidebarVisible;
          this.state.updateUIState('sidebarVisible', newState);
          this.ui.toggleSection('sidebar', newState);
          this.ui.updateCollapseButtons();
        } else {
          this.ui.addMessage('Cannot hide sidebar: At least one section must remain visible', 'system');
        }
      }

      toggleUserSection() {
        if (this.state.canHideSection('userSectionVisible')) {
          const newState = !this.state.uiState.userSectionVisible;
          this.state.updateUIState('userSectionVisible', newState);
          this.ui.toggleSection('userSection', newState);
          this.ui.updateCollapseButtons();
        } else {
          this.ui.addMessage('Cannot hide user section: At least one section must remain visible', 'system');
        }
      }

      toggleChatSection() {
        if (this.state.canHideSection('chatSectionVisible')) {
          const newState = !this.state.uiState.chatSectionVisible;
          this.state.updateUIState('chatSectionVisible', newState);
          this.ui.toggleSection('chatSection', newState);
          this.ui.updateCollapseButtons();
        } else {
          this.ui.addMessage('Cannot hide chat section: At least one section must remain visible', 'system');
        }
      }
    }

    // Initialize the application
    let app;
    
    document.addEventListener('DOMContentLoaded', () => {
      app = new AppController();
      
      // Make functions globally available
      window.sendMessage = () => app.sendMessage();
      window.performAction = (actionType) => app.performAction(actionType);
      window.handleKeyPress = (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          app.sendMessage();
        }
      };

      // UI Functions
      window.changeModel = (modelName) => app.changeModel(modelName);
      window.selectAutomationType = (type) => app.selectAutomationType(type);
      window.createNewChat = () => app.createNewChat();
      window.clearSession = () => app.clearSession();
      window.resetModel = () => {
        app.state.resetModel();
        location.reload();
      };
      
      // Section toggle functions
      window.toggleSidebar = () => app.toggleSidebar();
      window.toggleUserSection = () => app.toggleUserSection();
      window.toggleChatSection = () => app.toggleChatSection();
      
      // Debug functions
      window.checkModels = async () => {
        const models = await app.ollama.getAvailableModels();
        console.log('Available models:', models);
        app.ui.addMessage(`Available models: ${models.map(m => m.name).join(', ')}`, 'system');
      };

      // Add peek/restore logic for each section
      window.peekSidebar = function(show) {
        const sidebar = document.getElementById('sidebar');
        if (sidebar.classList.contains('collapsed')) {
          if (show) sidebar.classList.add('revealed');
          else sidebar.classList.remove('revealed');
        }
      };
      window.restoreSidebar = function() {
        if (app && app.state.canHideSection('sidebarVisible')) {
          app.state.updateUIState('sidebarVisible', true);
          app.ui.toggleSection('sidebar', true);
          app.ui.updateCollapseButtons();
        }
      };
      window.peekUserSection = function(show) {
        const userSection = document.getElementById('userSection');
        if (userSection.classList.contains('collapsed')) {
          if (show) userSection.classList.add('revealed');
          else userSection.classList.remove('revealed');
        }
      };
      window.restoreUserSection = function() {
        if (app && app.state.canHideSection('userSectionVisible')) {
          app.state.updateUIState('userSectionVisible', true);
          app.ui.toggleSection('userSection', true);
          app.ui.updateCollapseButtons();
        }
      };
      window.peekChatSection = function(show) {
        const chatSection = document.getElementById('chatSection');
        if (chatSection.classList.contains('collapsed')) {
          if (show) chatSection.classList.add('revealed');
          else chatSection.classList.remove('revealed');
        }
      };
      window.restoreChatSection = function() {
        if (app && app.state.canHideSection('chatSectionVisible')) {
          app.state.updateUIState('chatSectionVisible', true);
          app.ui.toggleSection('chatSection', true);
          app.ui.updateCollapseButtons();
        }
      };
    });

    const sectionIds = ['sidebar', 'userSection', 'chatSection'];

    function toggleSection(sectionId) {
      const visibleSections = sectionIds.filter(id => !document.getElementById(id).classList.contains('collapsed'));
      const section = document.getElementById(sectionId);

      if (!section.classList.contains('collapsed') && visibleSections.length === 1) {
        alert('At least one section must remain visible.');
        return;
      }
      section.classList.toggle('collapsed');
    }
  </script>
</body>
</html>